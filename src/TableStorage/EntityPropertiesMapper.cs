//<auto-generated/>
#nullable enable
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.ComponentModel;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text.Json;
using Azure.Data.Tables;

namespace Devlooped
{
    class EntityPropertiesMapper
    {
        static readonly ConcurrentDictionary<(Type, string), PropertyInfo[]> propertiesMap = new();
        static readonly ConcurrentDictionary<Type, IDictionary<string, string>> edmAnnotations = new();
        static readonly KeyValuePair<string, string> edmNone = new("", "");

        private EntityPropertiesMapper() { }

        internal static EntityPropertiesMapper Default { get; } = new EntityPropertiesMapper();

        public IDictionary<string, object> ToProperties<T>(T entity, string? partitionKeyProperty = default, string? rowKeyProperty = default) where T: notnull
        {
            var properties = propertiesMap.GetOrAdd((entity.GetType(), $"{partitionKeyProperty}|{rowKeyProperty}"), key => key.Item1
                .GetProperties()
                .Where(prop =>
                    prop.GetCustomAttribute<BrowsableAttribute>()?.Browsable != false &&
                    prop.Name != partitionKeyProperty &&
                    prop.Name != rowKeyProperty)
                .ToArray());

            var annotations = edmAnnotations.GetOrAdd(entity.GetType(), _ =>
            {
                var dictionary = properties
                    .Where(prop =>
                        prop.GetCustomAttribute<BrowsableAttribute>()?.Browsable != false &&
                        prop.Name != partitionKeyProperty &&
                        prop.Name != rowKeyProperty)
                    .Select(prop => prop.PropertyType switch
                    {
                        var type when type == typeof(byte[]) => new KeyValuePair<string, string>(prop.Name + "@odata.type", "Edm.Binary"),
                        //var type when type == typeof(DateTime) => new KeyValuePair<string, string>(prop.Name + "@odata.type", "Edm.DateTime"),
                        var type when type == typeof(DateTimeOffset) => new KeyValuePair<string, string>(prop.Name + "@odata.type", "Edm.DateTime"),
                        var type when type == typeof(Guid) => new KeyValuePair<string, string>(prop.Name + "@odata.type", "Edm.Guid"),
                        var type when type == typeof(long) => new KeyValuePair<string, string>(prop.Name + "@odata.type", "Edm.Int64"),
                        _ => edmNone,
                    })
                    // This is an unnecessary annotation, so skip it.
                    .Where(x => x.Key != edmNone.Key)
                    .ToDictionary(x => x.Key, x => x.Value);

                // Make sure the Timestamp property is always annotated as DateTime, since it can also
                // be read by the client using a string or a DateTime, according to our documentation.
                // It will typically never be written back, since it's a server-managed value, but this 
                // makes it more obvious and consistent with the Azure SDK behavior which always includes 
                // this annotation when using odata:minimalmetadata or fullmetadata.
                if (properties.Any(x => x.Name == nameof(ITableEntity.Timestamp)) && !dictionary.ContainsKey(nameof(ITableEntity.Timestamp)))
                    dictionary.Add(nameof(ITableEntity.Timestamp), "Edm.DateTime");

                return dictionary;
            });

            var values = properties
                .Select(prop => new { prop.Name, Value = prop.GetValue(entity) })
                .Where(pair => pair.Value != null)
                .ToDictionary(
                    pair => pair.Name,
                    pair =>
#if NET6_0_OR_GREATER
                    pair.Value is DateOnly date ? 
                    date.ToString("O") : 
#endif
                    // EDM annotation for date time requires persisting as UTC only, which is best practice too.
                    //pair.Value is DateTime dateTime ?
                    //dateTime.ToUniversalTime().ToString("O") :
                    pair.Value is DateTimeOffset dateOffset ? 
                    dateOffset.ToUniversalTime().ToString("O") :
                    pair.Value.GetType().IsEnum ? pair.Value!.ToString() : 
                    pair.Value!
                );

            // Add any required metadata annotations to improve persistence.
            foreach (var annotation in annotations)
            {
                values.Add(annotation.Key, annotation.Value);
            }

            return (IDictionary<string, object>)values;
        }

        /// <summary>
        /// Uses JSON deserialization to convert from the persisted entity data 
        /// to the entity type, so that the right constructor and property 
        /// setters can be invoked, even if they are internal/private.
        /// </summary>
        public T ToEntity<T>(TableEntity data, string? partitionKeyProperty = default, string? rowKeyProperty = default)
        {
            using var mem = new MemoryStream();
            using var writer = new Utf8JsonWriter(mem);

            // Write entity properties in json format so deserializer can 
            // perform its advanced ctor and conversion detection as usual.
            writer.WriteStartObject();

            if (partitionKeyProperty != null && !data.ContainsKey(partitionKeyProperty))
                writer.WriteString(partitionKeyProperty, data.PartitionKey);

            if (rowKeyProperty != null && !data.ContainsKey(rowKeyProperty))
                writer.WriteString(rowKeyProperty, data.RowKey);

            if (data.Timestamp != null && !data.ContainsKey(nameof(ITableEntity.Timestamp)))
                writer.WriteString(nameof(ITableEntity.Timestamp), data.Timestamp.Value.ToString("O"));

            foreach (var property in data)
            {
                switch (property.Value)
                {
                    case string value:
                        writer.WriteString(property.Key, value);
                        break;
                    case byte[] value:
                        writer.WriteBase64String(property.Key, value);
                        break;
                    case bool value:
                        writer.WriteBoolean(property.Key, value);
                        break;
                    case DateTime value:
                        writer.WriteString(property.Key, value);
                        break;
                    case DateTimeOffset value:
                        writer.WriteString(property.Key, value);
                        break;
                    case double value:
                        writer.WriteNumber(property.Key, value);
                        break;
                    case int value:
                        writer.WriteNumber(property.Key, value);
                        break;
                    case long value:
                        writer.WriteNumber(property.Key, value);
                        break;
                    case Guid value:
                        writer.WriteString(property.Key, value);
                        break;
                    default:
                        break;
                }
            }

            writer.WriteEndObject();
            writer.Flush();
            mem.Position = 0;

            var json = new StreamReader(mem).ReadToEnd();

            return DocumentSerializer.Default.Deserialize<T>(json)!;
        }
    }
}
