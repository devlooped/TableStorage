//<auto-generated/>
#nullable enable
#if NET8_0_OR_GREATER
using System;
using System.Buffers;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using Azure;
using Azure.Storage.Blobs;
using Azure.Storage.Blobs.Models;

namespace Devlooped
{
    partial class BlobStorage<T> : ITableStorage<T> where T : class
    {
        static readonly string documentType = typeof(T).FullName?.Replace('+', '.') ?? typeof(T).Name;
        static readonly string documentVersion;
        static readonly string documentMajorVersion;
        static readonly string documentMinorVersion;

        readonly AsyncLazy<BlobContainerClient> container;

        readonly IStringDocumentSerializer? stringSerializer;
        readonly IBinaryDocumentSerializer? binarySerializer;

        readonly Func<T, string> partitionKey;
        readonly Func<T, string> rowKey;

        readonly Func<Stream, T?> read;
        readonly Action<T, Stream> write;

        static BlobStorage()
        {
            var version = (typeof(T).Assembly.GetName().Version ?? new Version(1, 0));
            documentVersion = version.ToString(2);
            documentMajorVersion = version.Major.ToString();
            documentMinorVersion = version.Minor.ToString();
        }

        /// <summary>
        /// Initializes the blob storage.
        /// </summary>
        /// <param name="storageAccount">The <see cref="CloudStorageAccount"/> to use to connect to the table.</param>
        /// <param name="tableName">The logical table.</param>
        /// <param name="partitionKey">A function to determine the partition key for an entity of type <typeparamref name="T"/>.</param>
        /// <param name="rowKey">A function to determine the row key for an entity of type <typeparamref name="T"/>.</param>
        /// <param name="serializer">Optional serializer to use instead of the default <see cref="DocumentSerializer.Default"/>.</param>
        /// <param name="includeProperties">Whether to serialize properties as columns too, like table repositories, for easier querying.</param>
        protected internal BlobStorage(CloudStorageAccount storageAccount, string tableName, Func<T, string> partitionKey, Func<T, string> rowKey, IDocumentSerializer serializer)
            : this(storageAccount.CreateBlobServiceClient().GetBlobContainerClient(tableName ?? TableRepository.GetDefaultTableName<T>()), partitionKey, rowKey, serializer)
        {
        }

        /// <summary>
        /// Initializes the table repository.
        /// </summary>
        /// <param name="container">The blobs container for documents.</param>
        /// <param name="partitionKey">A function to determine the partition key for an entity of type <typeparamref name="T"/>.</param>
        /// <param name="rowKey">A function to determine the row key for an entity of type <typeparamref name="T"/>.</param>
        /// <param name="serializer">Optional serializer to use instead of the default <see cref="DocumentSerializer.Default"/>.</param>
        /// <param name="includeProperties">Whether to serialize properties as columns too, like table repositories, for easier querying.</param>
        protected internal BlobStorage(BlobContainerClient container, Func<T, string> partitionKey, Func<T, string> rowKey, IDocumentSerializer serializer)
        {
            this.container = new(async () =>
            {
                await container.CreateIfNotExistsAsync();
                return container;
            });

            this.partitionKey = partitionKey ?? PartitionKeyAttribute.CreateCompiledAccessor<T>();
            this.rowKey = rowKey ?? RowKeyAttribute.CreateCompiledAccessor<T>();

            stringSerializer = serializer as IStringDocumentSerializer;
            binarySerializer = serializer as IBinaryDocumentSerializer;

            if (stringSerializer == null && binarySerializer == null)
                throw new ArgumentException($"A valid serializer implementing either {nameof(IBinaryDocumentSerializer)} or {nameof(IStringDocumentSerializer)} is required.", nameof(serializer));

            TableName = container.Name;

            // Use the right strategy depending on the provided serializer.
            if (stringSerializer != null)
            {
                read = ReadString;
                write = WriteString;
            }
            else
            {
                read = ReadBinary;
                write = WriteBinary;
            }
        }

        public string TableName { get; }

        /// <inheritdoc />
        public async Task<bool> DeleteAsync(string partitionKey, string rowKey, CancellationToken cancellation = default)
        {
            var container = await this.container.Value.ConfigureAwait(false);

            var result = await container.DeleteBlobIfExistsAsync($"{partitionKey}/{rowKey}", cancellationToken: cancellation).ConfigureAwait(false);

            return result.Value;
        }

        /// <inheritdoc />
        public Task<bool> DeleteAsync(T entity, CancellationToken cancellation = default)
            => DeleteAsync(partitionKey(entity), rowKey(entity), cancellation);

        /// <inheritdoc />
        public async IAsyncEnumerable<T> EnumerateAsync(string? partitionKey = default, [EnumeratorCancellation] CancellationToken cancellation = default)
        {
            var container = await this.container.Value.ConfigureAwait(false);
            var prefix = default(string);
            if (!string.IsNullOrEmpty(partitionKey))
                prefix = partitionKey + "/";

            var results = container.GetBlobsAsync(prefix: prefix, cancellationToken: cancellation);

            var bufferPool = ArrayPool<byte>.Shared;

            await foreach (var item in results.WithCancellation(cancellation))
            {
                // Rent a buffer from the pool (adjust size based on expected blob size)
                var buffer = bufferPool.Rent(8192); // 8KB buffer, adjust as needed
                var client = container.GetBlobClient(item.Name);
                try
                {
                    var memory = new MemoryStream();
                    await client.DownloadToAsync(memory, cancellation).ConfigureAwait(false);
                    memory.Position = 0;

                    if (read(memory) is not T entity)
                        continue;

                    if (entity is IDocumentTimestamp ts)
                        ts.Timestamp = item.Properties.LastModified;

                    yield return entity;
                }
                finally
                {
                    // Return the buffer to the pool
                    bufferPool.Return(buffer);
                }
            }
        }

        /// <inheritdoc />
        public Task<T?> GetAsync(T entity, CancellationToken cancellation = default)
            => GetAsync(partitionKey(entity), rowKey(entity), cancellation);

        /// <inheritdoc />
        public async Task<T?> GetAsync(string partitionKey, string rowKey, CancellationToken cancellation = default)
        {
            if (string.IsNullOrEmpty(partitionKey) || string.IsNullOrEmpty(rowKey))
                throw new ArgumentException("Partition key and row key must not be null or empty.", nameof(partitionKey));

            var container = await this.container.Value.ConfigureAwait(false);
            var client = container.GetBlobClient($"{partitionKey}/{rowKey}");

            try
            {
                var memory = new MemoryStream();
                await client.DownloadToAsync(memory, cancellation).ConfigureAwait(false);
                memory.Position = 0;
                if (read(memory) is not T entity)
                    return default;

                if (entity is IDocumentTimestamp ts)
                    ts.Timestamp = (await client.GetPropertiesAsync(cancellationToken: cancellation)).Value.LastModified;

                return entity;
            }
            catch (RequestFailedException rfe) when (rfe.ErrorCode == BlobErrorCode.BlobNotFound || rfe.ErrorCode == BlobErrorCode.ContainerNotFound)
            {
                return default;
            }
        }

        /// <inheritdoc />
        public async Task<T> PutAsync(T entity, CancellationToken cancellation = default)
        {
            var container = await this.container.Value.ConfigureAwait(false);

            var partitionKey = this.partitionKey.Invoke(entity);
            var rowKey = this.rowKey.Invoke(entity);
            using var memory = new MemoryStream();
            write(entity, memory);
            memory.Position = 0;

            var client = container.GetBlobClient($"{partitionKey}/{rowKey}");
            var info = await client.UploadAsync(memory, new BlobUploadOptions
            {
                HttpHeaders = new BlobHttpHeaders
                {
                    ContentType = stringSerializer != null ? "application/json" : "application/octet-stream",
                },
                Metadata = new Dictionary<string, string>
                {
                    { "Type", documentType },
                    { "Version", documentVersion },
                    { "MajorVersion", documentMajorVersion },
                    { "MinorVersion", documentMinorVersion },
                },
            }, cancellation);

            if (entity is IDocumentTimestamp ts)
                ts.Timestamp = info.Value.LastModified;

            return entity;
        }

        public async Task PutAsync(IEnumerable<T> entities, CancellationToken cancellation = default)
        {
            var container = await this.container.Value.ConfigureAwait(false);

            foreach (var entity in entities)
            {
                var partitionKey = this.partitionKey.Invoke(entity);
                var rowKey = this.rowKey.Invoke(entity);
                using var memory = new MemoryStream();
                write(entity, memory);
                memory.Position = 0;

                var client = container.GetBlobClient($"{partitionKey}/{rowKey}");
                var info = await client.UploadAsync(memory, new BlobUploadOptions
                {
                    HttpHeaders = new BlobHttpHeaders
                    {
                        ContentType = stringSerializer != null ? "application/json" : "application/octet-stream",
                    },
                    Metadata = new Dictionary<string, string>
                    {
                        { "Type", documentType },
                        { "Version", documentVersion },
                        { "MajorVersion", documentMajorVersion },
                        { "MinorVersion", documentMinorVersion },
                    },
                }, cancellation);

                if (entity is IDocumentTimestamp ts)
                    ts.Timestamp = info.Value.LastModified;
            }
        }

        T? ReadString(Stream data)
        {
            data.Position = 0; 
            using var reader = new StreamReader(data, Encoding.UTF8, true, -1, leaveOpen: true);
            var content = reader.ReadToEnd();
            return stringSerializer!.Deserialize<T>(content);
        }

        void WriteString(T entity, Stream data)
        {
            data.SetLength(0);
            data.Position = 0;
            var content = stringSerializer!.Serialize(entity);
            data.Write(Encoding.UTF8.GetBytes(content));
        }

        T? ReadBinary(Stream stream) => binarySerializer!.Deserialize<T>(stream);

        void WriteBinary(T entity, Stream stream) => binarySerializer!.Serialize(entity, stream);

    }
}
#endif