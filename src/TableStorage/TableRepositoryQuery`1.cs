//<auto-generated/>
#nullable enable
using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Linq.Expressions;
using System.Net.Http;
using System.Reflection;
using System.Text;
using System.Text.Json;
using System.Text.RegularExpressions;
using System.Threading;
using System.Web;
using Azure.Data.Tables;
using Microsoft.OData.Client;

namespace Devlooped
{
    class TableRepositoryQuery<T> : IQueryable<T>, IQueryProvider, IAsyncEnumerable<T>
    {
        readonly CloudStorageAccount account;
        readonly IStringDocumentSerializer serializer;
        readonly string tableName;
        readonly string? partitionKeyProperty;
        readonly string? rowKeyProperty;
        readonly Expression expression;

        public TableRepositoryQuery(CloudStorageAccount account, IStringDocumentSerializer serializer, string tableName,
            string? partitionKeyProperty, string? rowKeyProperty, Expression? expression = default)
        {
            this.account = account;
            this.serializer = serializer;
            this.tableName = tableName;
            this.partitionKeyProperty = partitionKeyProperty;
            this.rowKeyProperty = rowKeyProperty;
            this.expression = expression ?? new DataServiceContext(account.TableEndpoint).CreateQuery<T>(tableName).Expression;
        }

        /// <summary>
        /// Allows scoping the query to a specific partition key. Used by <see cref="TablePartition{T}.CreateQuery"/>.
        /// </summary>
        internal string? PartitionKey { get; set; }

        public async IAsyncEnumerator<T> GetAsyncEnumerator(CancellationToken cancellation = default)
        {
            var query = (DataServiceQuery)new DataServiceContext(account.TableEndpoint).CreateQuery<T>(tableName)
                .Provider.CreateQuery(expression);

            // OData will translate the enum value in a filter to TYPENAME.'ENUMVALUE'.
            // The type name can contain the + sign if it's a nested type, too. So we
            // need to remove the type name plus the dot and just leave the string 
            // value as part of the filter string.
            var rawqs = Regex.Replace(
                query.RequestUri.GetComponents(UriComponents.Query, UriFormat.Unescaped),
                "(\\W)[\\w\\+\\.]+('\\w+')", "$1$2");

            // We need to count & break manually because $top is interpreted as the max records per page 
            // if the set matches more items. This is clearly unintuitive and *not* what one typically 
            // wants when using LINQ queries! See Note on https://docs.microsoft.com/en-us/rest/api/storageservices/querying-tables-and-entities#supported-query-options
            var qs = HttpUtility.ParseQueryString(rawqs);
            if (!long.TryParse(qs["$top"], out var top))
                top = -1;

            long count = 0;
            // Covers weird case of top == 0.
            if (count == top)
                yield break;

            // Collect the properties being projected, and append the built-in ones to them.
            if (expression.CanReduce)
            {
                var projection = new ProjectionVisitor();
                projection.Visit(expression);

                if (projection.Properties.Count > 0)
                {
                    var props = projection.Properties
                        .Concat(new[]
                        {
                        nameof(ITableEntity.PartitionKey),
                        nameof(ITableEntity.RowKey),
                        nameof(ITableEntity.ETag),
                        nameof(ITableEntity.Timestamp)
                        });

                    // append or replace the select query string
                    if (qs["$select"] is string select)
                        qs["$select"] = string.Join(",", new HashSet<string>(select.Split(',').Concat(props)));
                    else
                        qs["$select"] = string.Join(",", props);
                }
            }

            var filter = qs["$filter"];
            if (filter != null && (partitionKeyProperty != null || rowKeyProperty != null))
            {
                if (partitionKeyProperty != null && partitionKeyProperty != nameof(ITableEntity.PartitionKey))
                    filter = Regex.Replace(filter, partitionKeyProperty + "(\\W)", "PartitionKey$1");
                if (rowKeyProperty != null && rowKeyProperty != nameof(ITableEntity.RowKey))
                    filter = Regex.Replace(filter, rowKeyProperty + "(\\W)", "RowKey$1");

                qs["$filter"] = filter;
            }

            if (PartitionKey != null)
            {
                if (filter == null)
                    filter = "PartitionKey eq '" + PartitionKey + "'";
                else
                    filter = "PartitionKey eq '" + PartitionKey + "' and " + filter;

                qs["$filter"] = filter;
            }

            var builder = new UriBuilder(query.RequestUri)
            {
                Query = string.Join("&", qs.AllKeys.Select(x => $"{x}={qs[x]}"))
            };

            var request = new HttpRequestMessage(HttpMethod.Get, builder.Uri)
                .AddAuthorizationHeader(account);

            if (typeof(T) == typeof(TableEntity))
                request.Headers.TryAddWithoutValidation("Accept", "application/json;odata=minimalmetadata");

            var response = await Http.Client.SendAsync(request);
            while (true)
            {
                if (response.StatusCode == System.Net.HttpStatusCode.NotFound)
                    yield break;

                response.EnsureSuccessStatusCode();

                var json = await response.Content.ReadAsStringAsync();
                var doc = JsonDocument.Parse(json);

                foreach (var element in doc.RootElement.GetProperty("value").EnumerateArray())
                {
                    // Optimize code path for TableEntity, which is simpler.
                    if (typeof(T) == typeof(TableEntity))
                    {
                        var entity = new TableEntity(JsonElementToDictionary(element));
                        if (entity != null)
                        {
                            yield return (T)(object)entity;
                            count++;
                            if (count == top)
                                yield break;
                        }
                    }
                    else
                    {
                        var mem = new MemoryStream();
                        var writer = new Utf8JsonWriter(mem);

                        writer.WriteStartObject();

                        // Write the renamed key properties, if any.
                        if (partitionKeyProperty != null && partitionKeyProperty != nameof(ITableEntity.PartitionKey))
                            writer.WriteString(partitionKeyProperty, element.GetProperty("PartitionKey").GetString());
                        if (rowKeyProperty != null && rowKeyProperty != nameof(ITableEntity.RowKey))
                            writer.WriteString(rowKeyProperty, element.GetProperty("RowKey").GetString());

                        foreach (var property in element.EnumerateObject())
                            property.WriteTo(writer);

                        writer.WriteEndObject();
                        writer.Flush();

                        var data = Encoding.UTF8.GetString(mem.ToArray());
                        var item = serializer.Deserialize<T>(data);
                        if (item != null)
                        {
                            yield return item;
                            count++;
                            if (count == top)
                                yield break;
                        }
                    }
                }

                if (!response.Headers.TryGetValues("x-ms-continuation-NextPartitionKey", out var nextPartitionKeyValues) ||
                    nextPartitionKeyValues.FirstOrDefault() is not string nextPartitionKey ||
                    string.IsNullOrEmpty(nextPartitionKey) ||
                    !response.Headers.TryGetValues("x-ms-continuation-NextRowKey", out var nextRowKeyValues) ||
                    nextRowKeyValues.FirstOrDefault() is not string nextRowKey ||
                    string.IsNullOrEmpty(nextRowKey))
                    break;

                qs["NextPartitionKey"] = nextPartitionKey;
                qs["NextRowKey"] = nextRowKey;
                builder.Query = string.Join("&", qs.AllKeys.Select(x => $"{x}={qs[x]}"));

                request = new HttpRequestMessage(HttpMethod.Get, builder.Uri)
                    .AddAuthorizationHeader(account);

                response = await Http.Client.SendAsync(request);
            }
        }

        public IQueryable CreateQuery(Expression expression) => CreateQuery<T>(expression);

        public IQueryable<TElement> CreateQuery<TElement>(Expression expression)
            => typeof(TElement).IsAssignableFrom(typeof(T)) ?
                (IQueryable<TElement>)new TableRepositoryQuery<T>(account, serializer, tableName, partitionKeyProperty, rowKeyProperty, expression)
                {
                    PartitionKey = PartitionKey
                } :
                new TableRepositoryQuery<TElement>(account, serializer, tableName, partitionKeyProperty, rowKeyProperty, expression)
                {
                    PartitionKey = PartitionKey
                };

        public object Execute(Expression expression) => throw new NotSupportedException("Please use a asynchronous enumeration (i.e. 'async foreach') to execute the query.");

        public TResult Execute<TResult>(Expression expression) => throw new NotSupportedException("Please use a asynchronous enumeration (i.e. 'async foreach') to execute the query.");

        public IEnumerator<T> GetEnumerator() => throw new NotSupportedException("Please use an asynchronous enumeration (i.e. 'async foreach') instead.");

        public Type ElementType => typeof(T);

        public Expression Expression => expression;

        public IQueryProvider Provider => this;

        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

        static Dictionary<string, object> JsonElementToDictionary(JsonElement element)
        {
            var dictionary = new Dictionary<string, object>();
            var properties = element.EnumerateObject().ToDictionary(x => x.Name);

            foreach (var property in properties.Values)
            {
                if (property.Value.ValueKind == JsonValueKind.Null || 
                    property.Name.EndsWith("@odata.type"))
                    continue;

                // See heuristics from https://learn.microsoft.com/en-us/rest/api/storageservices/payload-format-for-table-service-operations#property-types-in-a-json-feed
                switch (property.Value.ValueKind)
                {
                    case JsonValueKind.String:
                        var value = property.Value.GetString();
                        if (value is null)
                            continue;

                        if (properties.TryGetValue(property.Name + "@odata.type", out var metadata) && 
                            metadata.Value.GetString() is string type)
                        {
                            // These cases will contain an annotation with the type.
                            switch (type)
                            {
                                case "Edm.Binary":
                                    dictionary.Add(property.Name, Convert.FromBase64String(value));
                                    continue;
                                case "Edm.DateTime":
                                    // Reading from Azure SDK will always return DateTimeOffset for dates, instead of date time.
                                    dictionary.Add(property.Name, DateTimeOffset.Parse(value, CultureInfo.InvariantCulture, DateTimeStyles.RoundtripKind));
                                    continue;
                                case "Edm.Guid":
                                    dictionary.Add(property.Name, Guid.Parse(value));
                                    continue;
                                case "Edm.Int64":
                                    dictionary.Add(property.Name, long.Parse(value, CultureInfo.InvariantCulture));
                                    continue;
                            }
                        } 
                        else if (property.Name == nameof(ITableEntity.Timestamp))
                        {
                            // Reading from Azure SDK will always return DateTimeOffset for dates, instead of date time.
                            dictionary.Add(property.Name, DateTimeOffset.Parse(value, CultureInfo.InvariantCulture, DateTimeStyles.RoundtripKind));
                            continue;
                        }

                        dictionary.Add(property.Name, value);
                        break;
                    case JsonValueKind.Number:
                        var number = property.Value.GetRawText();
                        if (number.Contains("."))
                            dictionary.Add(property.Name, property.Value.GetDouble());
                        else
                            dictionary.Add(property.Name, property.Value.GetInt32());
                        break;
                    case JsonValueKind.True:
                    case JsonValueKind.False:
                        dictionary.Add(property.Name, property.Value.GetBoolean());
                        break;
                    default:
                        // Ignore other non-native values and arrays.
                        break;
                }
            }

            return dictionary;
        }


        class ProjectionVisitor : ExpressionVisitor
        {
            readonly PropertyExpressionVisitor visitor = new PropertyExpressionVisitor();

            public HashSet<string> Properties => visitor.Properties;

            protected override Expression VisitMethodCall(MethodCallExpression node)
            {
                if (node.Method.Name == nameof(Queryable.Select) &&
                    node.Method.DeclaringType == typeof(Queryable))
                {
                    visitor.Visit(node.Arguments[1]);
                }
                return node;
            }

            class PropertyExpressionVisitor : ExpressionVisitor
            {
                public HashSet<string> Properties { get; } = new HashSet<string>();

                protected override Expression VisitMethodCall(MethodCallExpression node)
                {
                    if (node.Method.Name == "get_Item" && node.Method.GetParameters() is var parameters &&
                        parameters.Length == 1 &&
                        node.Arguments[0] is ConstantExpression constant && 
                        constant.Value is string value)
                    {
                        Properties.Add(value);
                    }

                    return node;
                }

                protected override Expression VisitMember(MemberExpression node)
                {
                    if (node.Member is PropertyInfo)
                        Properties.Add(node.Member.Name);

                    return base.VisitMember(node);
                }
            }
        }
    }
}
