//<auto-generated/>
#nullable enable
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text.RegularExpressions;
using Microsoft.OData.Edm;
using Microsoft.OData.UriParser;
using Microsoft.OData.UriParser.Aggregation;

namespace Devlooped;

/// <summary>
/// Helper class that fixes filter expressions containing DateTimeOffset comparisons.
/// </summary>
internal static partial class ODataExpression
{
    public static void VerifyNoOrderByTimestamp(string? expression)
    {
        if (string.IsNullOrEmpty(expression))
            return;

        // Check if the expression contains an order by on a timestamp property
        if (OrderByExpr().IsMatch(expression))
            throw new NotSupportedException("Ordering by timestamp is not supported in Azure Table Storage queries.");
    }

#if NET8_0_OR_GREATER
    [GeneratedRegex("timestamp\\s+(asc|desc)", RegexOptions.Compiled | RegexOptions.CultureInvariant | RegexOptions.IgnoreCase)]
    private static partial Regex OrderByExpr();
#else
    static Regex OrderByExpr() => orderByExpr;
    static readonly Regex orderByExpr = new Regex("timestamp\\s+(asc|desc)", RegexOptions.Compiled | RegexOptions.CultureInvariant | RegexOptions.IgnoreCase);
#endif

    /// <summary>
    /// Fixes filter expressions involving DateTimeOffset by converting them to the format expected by Azure Table Storage.
    /// </summary>
    /// <param name="filter">The filter expression to fix.</param>
    /// <returns>A fixed filter expression where DateTimeOffset comparisons are properly formatted.</returns>
    public static string? FixFilter(string? filter)
    {
        if (string.IsNullOrEmpty(filter))
            return filter;

        var parser = new UriQueryExpressionParser(int.MaxValue);
        var node = parser.ParseFilter(filter);

        if (node == null)
            return filter;

        try
        {
            return node.Accept(new QueryTokenToFilterStringVisitor());
        }
        catch (NotSupportedException)
        {
            return filter;
        }
    }

    class QueryTokenToFilterStringVisitor : ISyntacticTreeVisitor<string>
    {
        public string Visit(BinaryOperatorToken token)
        {
            string left = token.Left.Accept(this);
            string right = token.Right.Accept(this);
            string op = ToOperatorString(token.OperatorKind);
            return $"{left} {op} {right}";
        }

        public string Visit(UnaryOperatorToken token)
        {
            string operand = token.Operand.Accept(this);
            string op = ToOperatorString(token.OperatorKind);
            return $"{op} {operand}";
        }

        public string Visit(LiteralToken token)
        {
            // You may want to handle different literal types more carefully
            if (token.Value is string s)
                return $"'{s.Replace("'", "''")}'";
            if (token.Value is bool b)
                return b ? "true" : "false";
            if (token.Value is DateTimeOffset dto)
                return $"datetime'{dto.UtcDateTime.ToString("o", CultureInfo.InvariantCulture)}'";
            if (token.Value is DateTime dt)
                return $"datetime'{dt.ToUniversalTime().ToString("o", CultureInfo.InvariantCulture)}'";
            if (token.Value is Guid g)
                return $"guid'{g.ToString()}'";
            if (token.Value == null)
                return "null";

            return Convert.ToString(token.Value, CultureInfo.InvariantCulture)!;
        }

        public string Visit(EndPathToken token)
        {
            // Handles property/field access
            if (token.NextToken != null)
                return $"{token.Identifier}/{token.NextToken.Accept(this)}";
            return token.Identifier;
        }

        public string Visit(DottedIdentifierToken token)
        {
            if (token.NextToken != null)
                return $"{token.Identifier}/{token.NextToken.Accept(this)}";
            return token.Identifier;
        }

        public string Visit(FunctionCallToken token)
        {
            var args = token.Arguments?.Select(a => a.Accept(this)).ToArray() ?? Array.Empty<string>();
            string source = token.Source != null ? token.Source.Accept(this) + "/" : "";
            return $"{source}{token.Name}({string.Join(",", args)})";
        }

        public string Visit(FunctionParameterToken token) => token.ValueToken.Accept(this);

        public string Visit(AnyToken token)
        {
            var parent = token.Parent?.Accept(this);
            var expr = token.Expression?.Accept(this);
            return $"{parent}/any({token.Parameter}:{expr})";
        }

        public string Visit(AllToken token)
        {
            var parent = token.Parent?.Accept(this);
            var expr = token.Expression?.Accept(this);
            return $"{parent}/all({token.Parameter}:{expr})";
        }

        public string Visit(InToken token)
        {
            string left = token.Left.Accept(this);
            string right = token.Right.Accept(this);
            return $"{left} in {right}";
        }

        // Add more Visit methods for other token types as needed...

        // Helper to convert operator enums to OData string
        static string ToOperatorString(BinaryOperatorKind op)
        {
            return op switch
            {
                BinaryOperatorKind.And => "and",
                BinaryOperatorKind.Or => "or",
                BinaryOperatorKind.Equal => "eq",
                BinaryOperatorKind.NotEqual => "ne",
                BinaryOperatorKind.GreaterThan => "gt",
                BinaryOperatorKind.GreaterThanOrEqual => "ge",
                BinaryOperatorKind.LessThan => "lt",
                BinaryOperatorKind.LessThanOrEqual => "le",
                _ => throw new NotSupportedException($"Operator {op} not supported")
            };
        }

        static string ToOperatorString(UnaryOperatorKind op)
        {
            return op switch
            {
                UnaryOperatorKind.Not => "not",
                _ => throw new NotSupportedException($"Operator {op} not supported")
            };
        }

        // Implement stubs for other ISyntacticTreeVisitor<string> methods
        public string Visit(CustomQueryOptionToken token) => throw new NotSupportedException();
        public string Visit(AggregateExpressionToken token) => throw new NotSupportedException();
        public string Visit(CountSegmentToken tokenIn) => throw new NotImplementedException();
        public string Visit(ExpandToken tokenIn) => throw new NotImplementedException();
        public string Visit(ExpandTermToken tokenIn) => throw new NotImplementedException();
        public string Visit(LambdaToken tokenIn) => throw new NotImplementedException();
        public string Visit(InnerPathToken tokenIn) => throw new NotImplementedException();
        public string Visit(OrderByToken tokenIn) => throw new NotImplementedException();
        public string Visit(RangeVariableToken tokenIn) => throw new NotImplementedException();
        public string Visit(SelectToken tokenIn) => throw new NotImplementedException();
        public string Visit(SelectTermToken tokenIn) => throw new NotImplementedException();
        public string Visit(StarToken tokenIn) => throw new NotImplementedException();
        public string Visit(AggregateToken tokenIn) => throw new NotImplementedException();
        public string Visit(EntitySetAggregateToken tokenIn) => throw new NotImplementedException();
        public string Visit(GroupByToken tokenIn) => throw new NotImplementedException();
        // ...and so on for all required token types
    }
}