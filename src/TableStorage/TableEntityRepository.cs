//<auto-generated/>
#nullable enable
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;
using Azure;
using Azure.Data.Tables;

namespace Devlooped
{
    /// <inheritdoc />
    partial class TableEntityRepository : ITableRepository<TableEntity>
    {
        TableConnection tableConnection;

        /// <summary>
        /// Initializes the table repository.
        /// </summary>
        /// <param name="storageAccount">The <see cref="CloudStorageAccount"/> to use to connect to the table.</param>
        /// <param name="tableName">The table that backs this repository.</param>
        protected internal TableEntityRepository(CloudStorageAccount storageAccount, string tableName)
            => tableConnection = new TableConnection(storageAccount, tableName);

        /// <summary>
        /// Initializes the table repository.
        /// </summary>
        /// <param name="tableConnection">The table connection to use.</param>
        protected internal TableEntityRepository(TableConnection tableConnection) => this.tableConnection = tableConnection;

        /// <inheritdoc />
        public string TableName => tableConnection.TableName;

        /// <summary>
        /// The <see cref="TableUpdateMode"/> to use when updating an existing entity.
        /// </summary>
        public TableUpdateMode UpdateMode { get; set; }

        /// <summary>
        /// The strategy to use when updating an existing entity.
        /// </summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public UpdateStrategy UpdateStrategy
        {
            // Backs-compatible implementation
            get => UpdateMode == TableUpdateMode.Replace ? UpdateStrategy.Replace : UpdateStrategy.Merge;
            set => UpdateMode = value.UpdateMode;
        }

        /// <inheritdoc />
        public IQueryable<TableEntity> CreateQuery()
            => new TableRepositoryQuery<TableEntity>(
                tableConnection.StorageAccount, DocumentSerializer.Default, 
                tableConnection.TableName, nameof(ITableEntity.PartitionKey), nameof(ITableEntity.RowKey));

        /// <inheritdoc />
        public async Task<bool> DeleteAsync(string partitionKey, string rowKey, CancellationToken cancellation = default)
        {
            var table = await this.tableConnection.GetTableAsync().ConfigureAwait(false);

            var result = await table.DeleteEntityAsync(partitionKey, rowKey, cancellationToken: cancellation).ConfigureAwait(false);

            return !result.IsError;
        }

        /// <inheritdoc />
        public Task<bool> DeleteAsync(TableEntity entity, CancellationToken cancellation = default)
            => DeleteAsync(entity.PartitionKey, entity.RowKey, cancellation);

        /// <inheritdoc />
        public async IAsyncEnumerable<TableEntity> EnumerateAsync(string? partitionKey = default, [EnumeratorCancellation] CancellationToken cancellation = default)
        {
            var table = await this.tableConnection.GetTableAsync().ConfigureAwait(false);
            var filter = default(string);
            if (partitionKey != null)
                filter = "PartitionKey eq '" + partitionKey + "'";

            await foreach (var entity in table.QueryAsync<TableEntity>(filter, cancellationToken: cancellation).WithCancellation(cancellation))
            {
                yield return entity;
            }
        }

        /// <inheritdoc />
        public Task<TableEntity?> GetAsync(TableEntity entity, CancellationToken cancellation = default)
            => GetAsync(entity.PartitionKey, entity.RowKey, cancellation);

        /// <inheritdoc />
        public async Task<TableEntity?> GetAsync(string partitionKey, string rowKey, CancellationToken cancellation = default)
        {
            var table = await this.tableConnection.GetTableAsync().ConfigureAwait(false);

            try
            {
                var result = await table.GetEntityAsync<TableEntity>(partitionKey, rowKey, cancellationToken: cancellation)
                    .ConfigureAwait(false);

                return result.Value;
            }
            catch (RequestFailedException ex) when (ex.Status == 404)
            {
                return default;
            }
        }

        /// <inheritdoc />
        public async Task<TableEntity> PutAsync(TableEntity entity, CancellationToken cancellation = default)
        {
            var table = await this.tableConnection.GetTableAsync().ConfigureAwait(false);

            var result = await table.UpsertEntityAsync(entity, UpdateMode, cancellation)
                .ConfigureAwait(false);

            return (await GetAsync(entity.PartitionKey, entity.RowKey, cancellation).ConfigureAwait(false))!;
        }
    }
}
