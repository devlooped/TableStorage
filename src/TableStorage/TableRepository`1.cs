//<auto-generated/>
#nullable enable
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.ComponentModel;
using System.IO;
using System.Linq;
using System.Linq.Expressions;
using System.Net;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Azure.Cosmos.Table;

namespace Devlooped
{
    /// <inheritdoc />
    partial class TableRepository<T> : ITableRepository<T> where T : class
    {
        static readonly ConcurrentDictionary<Type, PropertyInfo[]> entityProperties = new();
        static readonly IStringDocumentSerializer serializer = DocumentSerializer.Default;

        readonly CloudStorageAccount storageAccount;
        readonly Func<T, string> partitionKey;
        readonly string? partitionKeyProperty;
        readonly Func<T, string> rowKey;
        readonly string? rowKeyProperty;
        readonly Task<CloudTable> table;

        /// <summary>
        /// Initializes the table repository.
        /// </summary>
        /// <param name="storageAccount">The <see cref="CloudStorageAccount"/> to use to connect to the table.</param>
        /// <param name="tableName">The table that backs this repository.</param>
        /// <param name="partitionKey">A function to determine the partition key for an entity of type <typeparamref name="T"/>.</param>
        /// <param name="rowKey">A function to determine the row key for an entity of type <typeparamref name="T"/>.</param>
        protected internal TableRepository(CloudStorageAccount storageAccount, string tableName, Expression<Func<T, string>> partitionKey, Expression<Func<T, string>> rowKey)
        {
            this.storageAccount = storageAccount;
            TableName = tableName ?? TableRepository.GetDefaultTableName<T>();

            this.partitionKey = partitionKey == null ?
                PartitionKeyAttribute.CreateCompiledAccessor<T>() :
                partitionKey.Compile();

            partitionKeyProperty = partitionKey.GetPropertyName();

            this.rowKey = rowKey == null ?
                RowKeyAttribute.CreateCompiledAccessor<T>() :
                rowKey.Compile();

            rowKeyProperty = rowKey.GetPropertyName();

            table = GetTableAsync(TableName);

        }

        /// <inheritdoc />
        public string TableName { get; }

        /// <summary>
        /// The strategy to use when updating an existing entity.
        /// </summary>
        public UpdateStrategy UpdateStrategy { get; set; } = UpdateStrategy.Replace;

        /// <inheritdoc />
        public IQueryable<T> CreateQuery() => new TableRepositoryQuery<T>(storageAccount, serializer, TableName, partitionKeyProperty, rowKeyProperty);

        /// <inheritdoc />
        public IAsyncEnumerable<T> QueryAsync(Expression<Func<T, bool>> predicate, CancellationToken cancellation = default)
            => (IAsyncEnumerable<T>)CreateQuery().Where(predicate);

        /// <inheritdoc />
        public async Task<bool> DeleteAsync(string partitionKey, string rowKey, CancellationToken cancellation = default)
        {
            var table = await this.table.ConfigureAwait(false);

            try
            {
                var result = await table.ExecuteAsync(TableOperation.Delete(
                    new TableEntity(partitionKey, rowKey) { ETag = "*" }), cancellation)
                    .ConfigureAwait(false);

                return result.HttpStatusCode >= 200 && result.HttpStatusCode <= 299;
            }
            catch (StorageException)
            {
                return false;
            }
        }

        /// <inheritdoc />
        public Task<bool> DeleteAsync(T entity, CancellationToken cancellation = default)
            => DeleteAsync(partitionKey(entity), rowKey(entity), cancellation);

        /// <inheritdoc />
        public async IAsyncEnumerable<T> EnumerateAsync(string? partitionKey = default, [EnumeratorCancellation] CancellationToken cancellation = default)
        {
            var table = await this.table;
            var query = new TableQuery<DynamicTableEntity>();
            if (partitionKey != null)
                query = query.Where(TableQuery.GenerateFilterCondition("PartitionKey", QueryComparisons.Equal, partitionKey));

            TableContinuationToken? continuation = null;
            do
            {
                var segment = await table.ExecuteQuerySegmentedAsync(query, continuation, cancellation)
                    .ConfigureAwait(false);

                continuation = segment.ContinuationToken;

                foreach (var entity in segment)
                    if (entity != null)
                        yield return ToEntity(entity);

            } while (continuation != null && !cancellation.IsCancellationRequested);
        }

        /// <inheritdoc />
        public async Task<T?> GetAsync(string partitionKey, string rowKey, CancellationToken cancellation = default)
        {
            var table = await this.table.ConfigureAwait(false);
            var result = await table.ExecuteAsync(TableOperation.Retrieve(partitionKey, rowKey), cancellation)
                .ConfigureAwait(false);

            if (result?.Result == null)
                return default;

            return ToEntity((DynamicTableEntity)result.Result);
        }

        /// <inheritdoc />
        public async Task<T> PutAsync(T entity, CancellationToken cancellation = default)
        {
            var partitionKey = this.partitionKey.Invoke(entity);
            var rowKey = this.rowKey.Invoke(entity);
            var properties = entityProperties.GetOrAdd(entity.GetType(), type => type
                .GetProperties()
                .Where(prop => 
                    prop.GetCustomAttribute<BrowsableAttribute>()?.Browsable != false && 
                    prop.Name != partitionKeyProperty && 
                    prop.Name != rowKeyProperty)
                .ToArray());

            var table = await this.table.ConfigureAwait(false);
            var values = properties
                .Select(prop => new { Name = prop.Name, Value = prop.GetValue(entity) })
                .Where(pair => pair.Value != null)
                .ToDictionary(pair => pair.Name, pair => EntityProperty.CreateEntityPropertyFromObject(pair.Value));

            var result = await table.ExecuteAsync(UpdateStrategy.CreateOperation(
                new DynamicTableEntity(partitionKey, rowKey, "*", values)), cancellation)
                .ConfigureAwait(false);

            // For merging, we need to actually retrieve the entity again, since the previous operation 
            // will just return the same entity we persisted, we may have fewer properties/values than 
            // the ones in storage.
            if (UpdateStrategy == UpdateStrategy.Merge)
                return (await GetAsync(partitionKey, rowKey, cancellation))!;

            return ToEntity((DynamicTableEntity)result.Result);
        }

        Task<CloudTable> GetTableAsync(string tableName) => Task.Run(async () =>
        {
            var tableClient = storageAccount.CreateCloudTableClient();
            var table = tableClient.GetTableReference(tableName);
            await table.CreateIfNotExistsAsync();
            return table;
        });

        /// <summary>
        /// Uses JSON deserialization to convert from the persisted entity data 
        /// to the entity type, so that the right constructor and property 
        /// setters can be invoked, even if they are internal/private.
        /// </summary>
        T ToEntity(DynamicTableEntity entity)
        {
            using var mem = new MemoryStream();
            using var writer = new Utf8JsonWriter(mem);
            
            // Write entity properties in json format so deserializer can 
            // perform its advanced ctor and conversion detection as usual.
            writer.WriteStartObject();

            if (partitionKeyProperty != null)
                writer.WriteString(partitionKeyProperty, entity.PartitionKey);

            if (rowKeyProperty != null)
                writer.WriteString(rowKeyProperty, entity.RowKey);

            writer.WriteString(nameof(ITableEntity.Timestamp), entity.Timestamp);

            foreach (var property in entity.Properties)
            {
                switch (property.Value.PropertyType)
                {
                    case EdmType.String:
                        writer.WriteString(property.Key, property.Value.StringValue);
                        break;
                    case EdmType.Binary:
                        writer.WriteBase64String(property.Key, property.Value.BinaryValue);
                        break;
                    case EdmType.Boolean when property.Value.BooleanValue != null:
                        writer.WriteBoolean(property.Key, (bool)property.Value.BooleanValue);
                        break;
                    case EdmType.DateTime when property.Value.DateTime != null:
                        writer.WriteString(property.Key, (DateTime)property.Value.DateTime);
                        break;
                    case EdmType.Double when property.Value.DoubleValue != null:
                        writer.WriteNumber(property.Key, (double)property.Value.DoubleValue);
                        break;
                    case EdmType.Guid when property.Value.GuidValue != null:
                        writer.WriteString(property.Key, (Guid)property.Value.GuidValue);
                        break;
                    case EdmType.Int32 when property.Value.Int32Value != null:
                        writer.WriteNumber(property.Key, (int)property.Value.Int32Value);
                        break;
                    case EdmType.Int64 when property.Value.Int64Value != null:
                        writer.WriteNumber(property.Key, (long)property.Value.Int64Value);
                        break;
                    default:
                        break;
                }
            }

            writer.WriteEndObject();
            writer.Flush();
            mem.Position = 0;

            var json = new StreamReader(mem).ReadToEnd();

            return serializer.Deserialize<T>(json)!;
        }
    }
}
