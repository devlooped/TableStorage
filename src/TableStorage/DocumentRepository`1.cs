//<auto-generated/>
#nullable enable
using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;
using System.Web;
using Azure;
using Azure.Data.Tables;
using Microsoft.OData.Client;
using static Devlooped.DocumentRepository;

namespace Devlooped
{
    /// <inheritdoc />
    partial class DocumentRepository<T> : IDocumentRepository<T> where T : class
    {
        static readonly string documentVersion;
        static readonly int documentMajorVersion;
        static readonly int documentMinorVersion;

        readonly CloudStorageAccount storageAccount;

        readonly IStringDocumentSerializer? stringSerializer;
        readonly IBinaryDocumentSerializer? binarySerializer;

        readonly Func<T, string> partitionKey;
        readonly Func<T, string> rowKey;
        readonly Task<TableClient> table;

        readonly Func<Func<IQueryable<IDocumentEntity>, IQueryable<IDocumentEntity>>, CancellationToken, IAsyncEnumerable<T>> enumerate;
        readonly Func<string, string, CancellationToken, Task<T?>> get;
        readonly Func<T, CancellationToken, Task<T>> put;

        static DocumentRepository()
        {
            var version = (typeof(T).Assembly.GetName().Version ?? new Version(1, 0));
            documentVersion = version.ToString(2);
            documentMajorVersion = version.Major;
            documentMinorVersion = version.Minor;
        }

        /// <summary>
        /// Initializes the table repository.
        /// </summary>
        /// <param name="storageAccount">The <see cref="CloudStorageAccount"/> to use to connect to the table.</param>
        /// <param name="tableName">The table that backs this repository.</param>
        /// <param name="partitionKey">A function to determine the partition key for an entity of type <typeparamref name="T"/>.</param>
        /// <param name="rowKey">A function to determine the row key for an entity of type <typeparamref name="T"/>.</param>
        /// <param name="serializer">Optional serializer to use instead of the default <see cref="DocumentSerializer.Default"/>.</param>
        protected internal DocumentRepository(CloudStorageAccount storageAccount, string tableName, Func<T, string> partitionKey, Func<T, string> rowKey, IDocumentSerializer serializer)
        {
            this.storageAccount = storageAccount;
            TableName = tableName ?? TableRepository.GetDefaultTableName<T>();

            this.partitionKey = partitionKey ?? PartitionKeyAttribute.CreateCompiledAccessor<T>();
            this.rowKey = rowKey ?? RowKeyAttribute.CreateCompiledAccessor<T>();

            stringSerializer = serializer as IStringDocumentSerializer;
            binarySerializer = serializer as IBinaryDocumentSerializer;

            if (stringSerializer == null && binarySerializer == null)
                throw new ArgumentException($"A valid serializer implementing either {nameof(IBinaryDocumentSerializer)} or {nameof(IStringDocumentSerializer)} is required.", nameof(serializer));

            // Use the right strategy depending on the provided serializer.
            if (stringSerializer != null)
            {
                enumerate = EnumerateStringAsync;
                get = GetStringAsync;
                put = PutStringAsync;
            }
            else
            {
                enumerate = EnumerateBinaryAsync;
                get = GetBinaryAsync;
                put = PutBinaryAsync;
            }

            table = GetTableAsync(TableName);
        }

        /// <inheritdoc />
        public string TableName { get; }

        /// <inheritdoc />
        public async Task<bool> DeleteAsync(string partitionKey, string rowKey, CancellationToken cancellation = default)
        {
            var table = await this.table.ConfigureAwait(false);

            var result = await table.DeleteEntityAsync(partitionKey, rowKey, cancellationToken: cancellation).ConfigureAwait(false);

            return !result.IsError;
        }

        /// <inheritdoc />
        public Task<bool> DeleteAsync(T entity, CancellationToken cancellation = default)
            => DeleteAsync(partitionKey(entity), rowKey(entity), cancellation);

        /// <inheritdoc />
        public IAsyncEnumerable<T> EnumerateAsync(string? partitionKey = default, CancellationToken cancellation = default)
            => enumerate(query => partitionKey == null ? query : query.Where(e => e.PartitionKey == partitionKey), cancellation);

        /// <inheritdoc />
        public IAsyncEnumerable<T> EnumerateAsync(Expression<Func<IDocumentEntity, bool>> predicate, CancellationToken cancellation = default)
            => enumerate(query => query.Where(predicate), cancellation);

        /// <inheritdoc />
        public Task<T?> GetAsync(string partitionKey, string rowKey, CancellationToken cancellation = default)
            => get(partitionKey, rowKey, cancellation);

        /// <inheritdoc />
        public Task<T> PutAsync(T entity, CancellationToken cancellation = default)
            => put(entity, cancellation);

        #region Binary

        async IAsyncEnumerable<T> EnumerateBinaryAsync(Func<IQueryable<IDocumentEntity>, IQueryable<IDocumentEntity>> filter, [EnumeratorCancellation] CancellationToken cancellation = default)
        {
            var query = new TableRepositoryQuery<BinaryDocumentEntity>(
                storageAccount,
                DocumentSerializer.Default,
                TableName,
                nameof(IDocumentEntity.PartitionKey),
                nameof(IDocumentEntity.RowKey));

            query = (TableRepositoryQuery<BinaryDocumentEntity>)filter(query);

            await foreach (var entity in query.WithCancellation(cancellation))
            {
                if (entity?.Document is byte[] document)
                {
                    var value = binarySerializer!.Deserialize<T>(document);
                    if (value != null)
                        yield return value;
                }
            }
        }

        async Task<T?> GetBinaryAsync(string partitionKey, string rowKey, CancellationToken cancellation = default)
        {
            var table = await this.table.ConfigureAwait(false);

            try
            {
                var result = await table.GetEntityAsync<BinaryDocumentEntity>(partitionKey, rowKey, cancellationToken: cancellation).ConfigureAwait(false);

                var document = result.Value.Document;
                if (document == null)
                    return default;

                return binarySerializer!.Deserialize<T>(document);

            }
            catch (RequestFailedException ex) when (ex.Status == 404)
            {
                return default;
            }
        }

        async Task<T> PutBinaryAsync(T entity, CancellationToken cancellation = default)
        {
            var partitionKey = this.partitionKey.Invoke(entity);
            var rowKey = this.rowKey.Invoke(entity);
            var table = await this.table.ConfigureAwait(false);

            // We use Replace because all the existing entity data is in a single 
            // column, no point in merging since it can't be done at that level anyway.
            var result = await table.UpsertEntityAsync(new BinaryDocumentEntity(partitionKey, rowKey)
            {
                Document = binarySerializer!.Serialize(entity),
                Type = typeof(T).FullName?.Replace('+', '.'),
                Version = documentVersion,
                MajorVersion = documentMajorVersion,
                MinorVersion = documentMinorVersion,
            }, TableUpdateMode.Replace, cancellation).ConfigureAwait(false);

            return await GetBinaryAsync(partitionKey, rowKey, cancellation).ConfigureAwait(false) ?? entity;
        }

        #endregion

        #region String

        async IAsyncEnumerable<T> EnumerateStringAsync(Func<IQueryable<IDocumentEntity>, IQueryable<IDocumentEntity>> filter, [EnumeratorCancellation] CancellationToken cancellation = default)
        {
            IQueryable<IDocumentEntity> query = new TableRepositoryQuery<DocumentEntity>(
                storageAccount,
                DocumentSerializer.Default,
                TableName, null, null);

            var results = (IAsyncEnumerable<IDocumentEntity>)filter(query);

            await foreach (var entity in results.WithCancellation(cancellation))
            {
                if (entity is DocumentEntity document && 
                    document.Document is string data)
                {
                    var value = stringSerializer!.Deserialize<T>(data);
                    if (value != null)
                        yield return value;
                }
            }
        }

        async Task<T?> GetStringAsync(string partitionKey, string rowKey, CancellationToken cancellation = default)
        {
            var table = await this.table.ConfigureAwait(false);

            try
            {
                var result = await table.GetEntityAsync<DocumentEntity>(partitionKey, rowKey, cancellationToken: cancellation).ConfigureAwait(false);

                var document = result.Value.Document;
                if (document == null)
                    return default;

                return stringSerializer!.Deserialize<T>(document);
            }
            catch (RequestFailedException ex) when (ex.Status == 404)
            {
                return default;
            }
        }

        async Task<T> PutStringAsync(T entity, CancellationToken cancellation = default)
        {
            var partitionKey = this.partitionKey.Invoke(entity);
            var rowKey = this.rowKey.Invoke(entity);
            var table = await this.table.ConfigureAwait(false);

            // We use Replace because all the existing entity data is in a single 
            // column, no point in merging since it can't be done at that level anyway.
            var result = await table.UpsertEntityAsync(new DocumentEntity(partitionKey, rowKey)
            {
                Document = stringSerializer!.Serialize(entity),
                Type = typeof(T).FullName?.Replace('+', '.'),
                Version = documentVersion,
                MajorVersion = documentMajorVersion,
                MinorVersion = documentMinorVersion,
            }, TableUpdateMode.Replace, cancellation).ConfigureAwait(false);

            return await GetStringAsync(partitionKey, rowKey, cancellation).ConfigureAwait(false) ?? entity;
        }

        #endregion

        Task<TableClient> GetTableAsync(string tableName) => Task.Run(async () =>
        {
            var tableClient = storageAccount.CreateTableServiceClient();
            var table = tableClient.GetTableClient(tableName);
            await table.CreateIfNotExistsAsync();
            return table;
        });
    }
}