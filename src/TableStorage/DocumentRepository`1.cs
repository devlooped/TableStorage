//<auto-generated/>
#nullable enable
using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Azure.Cosmos.Table;

namespace Devlooped
{
    /// <inheritdoc />
    partial class DocumentRepository<T> : ITableRepository<T> where T : class
    {
        static readonly string documentVersion = (typeof(T).Assembly.GetName().Version ?? new Version(1, 0)).ToString(2);

        readonly CloudStorageAccount storageAccount;

        readonly IStringDocumentSerializer? stringSerializer;
        readonly IBinaryDocumentSerializer? binarySerializer;

        readonly Func<T, string> partitionKey;
        readonly Func<T, string> rowKey;
        readonly Task<CloudTable> table;

        readonly Func<string, CancellationToken, IAsyncEnumerable<T>> enumerate;
        readonly Func<string, string, CancellationToken, Task<T?>> get;
        readonly Func<T, CancellationToken, Task<T>> put;

        /// <summary>
        /// Initializes the table repository.
        /// </summary>
        /// <param name="storageAccount">The <see cref="CloudStorageAccount"/> to use to connect to the table.</param>
        /// <param name="tableName">The table that backs this repository.</param>
        /// <param name="partitionKey">A function to determine the partition key for an entity of type <typeparamref name="T"/>.</param>
        /// <param name="rowKey">A function to determine the row key for an entity of type <typeparamref name="T"/>.</param>
        protected internal DocumentRepository(CloudStorageAccount storageAccount, string tableName, Func<T, string> partitionKey, Func<T, string> rowKey, IDocumentSerializer serializer)
        {
            this.storageAccount = storageAccount;
            TableName = tableName ?? TableRepository.GetDefaultTableName<T>();

            this.partitionKey = partitionKey ?? PartitionKeyAttribute.CreateCompiledAccessor<T>();
            this.rowKey = rowKey ?? RowKeyAttribute.CreateCompiledAccessor<T>();

            stringSerializer = serializer as IStringDocumentSerializer;
            binarySerializer = serializer as IBinaryDocumentSerializer;

            if (stringSerializer == null && binarySerializer == null)
                throw new ArgumentException($"A valid serializer implementing either {nameof(IBinaryDocumentSerializer)} or {nameof(IStringDocumentSerializer)} is required.", nameof(serializer));

            // Use the right strategy depending on the provided serializer.
            if (stringSerializer != null)
            {
                enumerate = EnumerateStringAsync;
                get = GetStringAsync;
                put = PutStringAsync;
            }
            else
            {
                enumerate = EnumerateBinaryAsync;
                get = GetBinaryAsync;
                put = PutBinaryAsync;
            }

            table = GetTableAsync(TableName);
        }

        /// <inheritdoc />
        public string TableName { get; }

        /// <inheritdoc />
        public async Task DeleteAsync(string partitionKey, string rowKey, CancellationToken cancellation = default)
        {
            var table = await this.table.ConfigureAwait(false);

            await table.ExecuteAsync(TableOperation.Delete(
                new TableEntity(partitionKey, rowKey) { ETag = "*" }), cancellation)
                .ConfigureAwait(false);
        }

        /// <inheritdoc />
        public async Task DeleteAsync(T entity, CancellationToken cancellation = default)
        {
            var partitionKey = this.partitionKey.Invoke(entity);
            var rowKey = this.rowKey.Invoke(entity);
            var table = await this.table.ConfigureAwait(false);

            await table.ExecuteAsync(TableOperation.Delete(
                new TableEntity(partitionKey, rowKey) { ETag = "*" }), cancellation)
                .ConfigureAwait(false);
        }

        /// <inheritdoc />
        public IAsyncEnumerable<T> EnumerateAsync(string partitionKey, CancellationToken cancellation = default) 
            => enumerate(partitionKey, cancellation);

        /// <inheritdoc />
        public Task<T?> GetAsync(string partitionKey, string rowKey, CancellationToken cancellation = default)
            => get(partitionKey, rowKey, cancellation);

        /// <inheritdoc />
        public Task<T> PutAsync(T entity, CancellationToken cancellation = default)
            => put(entity, cancellation);

        #region Binary

        async IAsyncEnumerable<T> EnumerateBinaryAsync(string partitionKey, [EnumeratorCancellation] CancellationToken cancellation = default)
        {
            var table = await this.table.ConfigureAwait(false);
            var query = new TableQuery<BinaryDocumentEntity>()
                .Where(TableQuery.GenerateFilterCondition("PartitionKey", QueryComparisons.Equal, partitionKey));

            TableContinuationToken? continuation = null;
            do
            {
                var segment = await table.ExecuteQuerySegmentedAsync(query, continuation, cancellation)
                    .ConfigureAwait(false);

                foreach (var entity in segment)
                {
                    if (entity != null && entity.Document != null)
                    {
                        var value = binarySerializer!.Deserialize<T>(entity.Document);
                        if (value != null)
                            yield return value;
                    }
                }

            } while (continuation != null && !cancellation.IsCancellationRequested);
        }

        async Task<T?> GetBinaryAsync(string partitionKey, string rowKey, CancellationToken cancellation = default)
        {
            var table = await this.table.ConfigureAwait(false);
            var result = await table.ExecuteAsync(TableOperation.Retrieve<BinaryDocumentEntity>(
                partitionKey, rowKey),
                cancellation)
                .ConfigureAwait(false);

            var document = (BinaryDocumentEntity?)result.Result;
            if (document?.Document == null)
                return default;

            return binarySerializer!.Deserialize<T>(document.Document);
        }

        async Task<T> PutBinaryAsync(T entity, CancellationToken cancellation = default)
        {
            var partitionKey = this.partitionKey.Invoke(entity);
            var rowKey = this.rowKey.Invoke(entity);
            var table = await this.table.ConfigureAwait(false);

            // We use Replace because all the existing entity data is in a single 
            // column, no point in merging since it can't be done at that level anyway.
            var result = await table.ExecuteAsync(TableOperation.InsertOrReplace(
                new BinaryDocumentEntity(partitionKey, rowKey)
                {
                    ETag = "*",
                    Document = binarySerializer!.Serialize(entity),
                    DocumentType = typeof(T).FullName,
                    DocumentVersion = documentVersion,
                }), cancellation)
                .ConfigureAwait(false);

            var document = (BinaryDocumentEntity)result.Result;
            if (document.Document == null)
                return entity;

            return binarySerializer.Deserialize<T>(document.Document) ?? entity;
        }

        #endregion

        #region String

        async IAsyncEnumerable<T> EnumerateStringAsync(string partitionKey, [EnumeratorCancellation] CancellationToken cancellation = default)
        {
            var table = await this.table.ConfigureAwait(false);
            var query = new TableQuery<DocumentEntity>()
                .Where(TableQuery.GenerateFilterCondition("PartitionKey", QueryComparisons.Equal, partitionKey));

            TableContinuationToken? continuation = null;
            do
            {
                var segment = await table.ExecuteQuerySegmentedAsync(query, continuation, cancellation)
                    .ConfigureAwait(false);

                foreach (var entity in segment)
                {
                    if (entity != null && entity.Document != null)
                    {
                        var value = stringSerializer!.Deserialize<T>(entity.Document);
                        if (value != null)
                            yield return value;
                    }
                }

            } while (continuation != null && !cancellation.IsCancellationRequested);
        }

        async Task<T?> GetStringAsync(string partitionKey, string rowKey, CancellationToken cancellation = default)
        {
            var table = await this.table.ConfigureAwait(false);
            var result = await table.ExecuteAsync(TableOperation.Retrieve<DocumentEntity>(
                partitionKey, rowKey),
                cancellation)
                .ConfigureAwait(false);

            var document = (DocumentEntity?)result.Result;
            if (document?.Document == null)
                return default;

            return stringSerializer!.Deserialize<T>(document.Document);
        }

        async Task<T> PutStringAsync(T entity, CancellationToken cancellation = default)
        {
            var partitionKey = this.partitionKey.Invoke(entity);
            var rowKey = this.rowKey.Invoke(entity);
            var table = await this.table.ConfigureAwait(false);

            // We use Replace because all the existing entity data is in a single 
            // column, no point in merging since it can't be done at that level anyway.
            var result = await table.ExecuteAsync(TableOperation.InsertOrReplace(
                new DocumentEntity(partitionKey, rowKey)
                {
                    ETag = "*",
                    Document = stringSerializer!.Serialize(entity),
                    DocumentType = typeof(T).FullName,
                    DocumentVersion = documentVersion,
                }), cancellation)
                .ConfigureAwait(false);

            var document = (DocumentEntity)result.Result;
            if (document.Document == null)
                return entity;

            return stringSerializer.Deserialize<T>(document.Document) ?? entity;
        }

        #endregion

        async Task<CloudTable> GetTableAsync(string tableName)
        {
            var tableClient = storageAccount.CreateCloudTableClient();
            var table = tableClient.GetTableReference(tableName);
            await table.CreateIfNotExistsAsync();
            return table;
        }

        class BinaryDocumentEntity : TableEntity
        {
            public BinaryDocumentEntity() { }
            public BinaryDocumentEntity(string partitionKey, string rowKey) : base(partitionKey, rowKey) { }
            public byte[]? Document { get; set; }
            public string? DocumentType { get; set; }
            public string? DocumentVersion { get; set; }
        }

        class DocumentEntity : TableEntity
        {
            public DocumentEntity() { }
            public DocumentEntity(string partitionKey, string rowKey) : base(partitionKey, rowKey) { }
            public string? Document { get; set; }
            public string? DocumentType { get; set; }
            public string? DocumentVersion { get; set; }
        }
    }
}