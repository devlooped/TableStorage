//<auto-generated/>
#nullable enable
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Linq;
using System.Linq.Expressions;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;
using Azure;
using Microsoft.CSharp.RuntimeBinder;
using Mono.Linq.Expressions;

namespace Devlooped;

/// <inheritdoc />
public class MemoryRepository<T> : ITableRepository<T>, IDocumentRepository<T> where T : class
{
    readonly ConcurrentDictionary<string, ConcurrentDictionary<string, T>> storage = new();
    readonly ConcurrentDictionary<DocumentEntity, T> documents = new(new DocumentEntityEqualityComparer());
    readonly Func<T, string> partitionKey;
    readonly string? partitionKeyProperty;
    readonly Func<T, string> rowKey;
    readonly string? rowKeyProperty;
    Func<T, DateTimeOffset?, T>? setTimestamp; 

    /// <summary>
    /// Initializes the memory repository.
    /// </summary>
    public MemoryRepository()
        : this(TableRepository.GetDefaultTableName<T>(),
            PartitionKeyAttribute.CreateAccessor<T>(),
            RowKeyAttribute.CreateAccessor<T>())
    { }

    /// <summary>
    /// Initializes the table repository.
    /// </summary>
    /// <param name="tableName">The table that backs this repository.</param>
    public MemoryRepository(string tableName)
        : this(tableName ?? TableRepository.GetDefaultTableName<T>(),
            PartitionKeyAttribute.CreateAccessor<T>(),
            RowKeyAttribute.CreateAccessor<T>())
    { }

    /// <summary>
    /// Initializes the table repository.
    /// </summary>
    /// <param name="tableName">The table that backs this repository.</param>
    /// <param name="partitionKey">A function to determine the partition key for an entity of type <typeparamref name="T"/>.</param>
    /// <param name="rowKey">A function to determine the row key for an entity of type <typeparamref name="T"/>.</param>
    public MemoryRepository(string tableName, Expression<Func<T, string>>? partitionKey, Expression<Func<T, string>>? rowKey)
    {
        this.TableName = tableName;
        this.partitionKey = partitionKey == null ?
            PartitionKeyAttribute.CreateCompiledAccessor<T>() :
            partitionKey.Compile();

        partitionKeyProperty = partitionKey.GetPropertyName();

        this.rowKey = rowKey == null ?
            RowKeyAttribute.CreateCompiledAccessor<T>() :
            rowKey.Compile();

        rowKeyProperty = rowKey.GetPropertyName();
    }

    /// <inheritdoc />
    public string TableName { get; private set; }

    /// <inheritdoc />
    public IQueryable<T> CreateQuery() => storage.Values.SelectMany(x => x.Values).AsQueryable();

    public IQueryable<T> CreateQuery(string partitionKey)
        => storage.TryGetValue(partitionKey, out var values) ? values.Values.AsQueryable() : Enumerable.Empty<T>().AsQueryable();

    /// <inheritdoc />
    public Task<bool> DeleteAsync(string partitionKey, string rowKey, CancellationToken cancellation = default)
    {
        if (storage.TryGetValue(partitionKey, out var partition))
            partition.TryRemove(rowKey, out _);

        // This operation is atomic, the storage one isn't, so use this as the return value.
        return Task.FromResult(documents.TryRemove(new DocumentEntity(partitionKey, rowKey), out _));
    }

    /// <inheritdoc />
    public Task<bool> DeleteAsync(T entity, CancellationToken cancellation = default)
        => DeleteAsync(partitionKey(entity), rowKey(entity), cancellation);

    /// <inheritdoc />
    public async IAsyncEnumerable<T> EnumerateAsync(string? partitionKey = default, [EnumeratorCancellation] CancellationToken cancellation = default)
    {
        if (partitionKey != null)
        {
            if (storage.TryGetValue(partitionKey, out var partition))
            {
                foreach (var entity in partition.Values)
                {
                    yield return entity;
                    await Task.Yield();
                }
            }
            yield break;
        }

        foreach (var partition in storage.Values)
        {
            foreach (var entity in partition.Values)
            {
                yield return entity;
                await Task.Yield();
            }
        }
    }

    /// <inheritdoc />
    public async IAsyncEnumerable<T> EnumerateAsync(Expression<Func<IDocumentEntity, bool>> predicate, [EnumeratorCancellation] CancellationToken cancellation = default)
    {
#if DEBUG
        var reduced = new ConstantReducer().Visit(predicate);
        var csharp = CSharp.ToCSharpCode(reduced);
        Debug.WriteLine(csharp);
#endif

        var func = predicate.Compile();
        foreach (var item in documents)
        {
            if (cancellation.IsCancellationRequested)
                break;
            if (func(item.Key))
            {
                if (item.Value is IDocumentTimestamp ts)
                    ts.Timestamp = item.Key.Timestamp;
                yield return item.Value;
            }

            await Task.Yield();
        }
    }

    /// <inheritdoc />
    public Task<T?> GetAsync(T entity, CancellationToken cancellation = default)
        => GetAsync(partitionKey(entity), rowKey(entity), cancellation);

    /// <inheritdoc />
    public async Task<T?> GetAsync(string partitionKey, string rowKey, CancellationToken cancellation = default)
    {
        if (documents.TryGetValue(new DocumentEntity(partitionKey, rowKey), out var entity))
            return await Task.FromResult(entity);

        return await Task.FromResult(default(T));
    }

    /// <inheritdoc />
    public async Task<T> PutAsync(T entity, CancellationToken cancellation = default)
    {
        var partitionKey = this.partitionKey.Invoke(entity);
        var rowKey = this.rowKey(entity);

        storage.GetOrAdd(partitionKey, _ => new ConcurrentDictionary<string, T>())[rowKey] = entity;
        var updated = documents.AddOrUpdate(new DocumentEntity(partitionKey, rowKey),
            key => SetTimestamp(entity, key.Timestamp),
            (key, value) =>
            {
                key.Timestamp = DateTimeOffset.UtcNow;
                return SetTimestamp(entity, key.Timestamp);
            }
        );

        return await Task.FromResult(updated);
    }

    /// <inheritdoc />
    public async Task PutAsync(IEnumerable<T> entities, CancellationToken cancellation = default)
    {
        foreach (var entity in entities)
            await PutAsync(entity, cancellation);

        await Task.CompletedTask;
    }

    T SetTimestamp(T entity, DateTimeOffset? timestamp)
    {
        if (setTimestamp != null)
            return setTimestamp(entity, timestamp);

        if (entity is IDocumentTimestamp ts)
        {
            ts.Timestamp = timestamp;
            setTimestamp = (e, t) =>
            {
                ((IDocumentTimestamp)e).Timestamp = t;
                return e;
            };
            return entity;
        }

        try
        {
            dynamic dyn = entity;
            dyn.Timestamp = timestamp;
            setTimestamp = (e, t) =>
            {
                ((dynamic)e).Timestamp = t;
                return e;
            };
            return entity;
        }
        catch (RuntimeBinderException)
        {
            try
            {
                dynamic dyn = entity;
                var dt = timestamp.HasValue ? timestamp.Value.DateTime : (DateTime?)null;
                dyn.Timestamp = dt;
                setTimestamp = (e, t) =>
                {
                    var dt = timestamp.HasValue ? timestamp.Value.DateTime : (DateTime?)null;
                    ((dynamic)e).Timestamp = dt;
                    return e;
                };
                return entity;
            }
            catch (RuntimeBinderException)
            {
                setTimestamp = (e, t) => e;
                return entity;
            }
        }
        catch (InvalidOperationException)
        {
            setTimestamp = (e, t) => e;
            return entity;
        }
    }

    class DocumentEntity(string partitionKey, string rowKey) : IDocumentEntity
    {
        static readonly Version version = (typeof(T).Assembly.GetName().Version ?? new Version(1, 0));
        static readonly string documentType = typeof(T).FullName?.Replace('+', '.') ?? typeof(T).Name;
        static readonly string documentVersion = version.ToString(2);

        public string PartitionKey { get; set; } = partitionKey;
        public string RowKey { get; set; } = rowKey;
        public DateTimeOffset? Timestamp { get; set; } = DateTimeOffset.UtcNow;
        public ETag ETag { get; set; } = ETag.All;

        public string? Type => documentType;
        public string? Version => documentVersion;
        public int? MajorVersion => version.Major;
        public int? MinorVersion => version.Minor;
    }

    class DocumentEntityEqualityComparer : IEqualityComparer<DocumentEntity>
    {
        public bool Equals(DocumentEntity x, DocumentEntity y) => x.PartitionKey == y.PartitionKey && x.RowKey == y.RowKey;
        public int GetHashCode(DocumentEntity obj) => HashCode.Combine(obj.PartitionKey, obj.RowKey);
    }
}

